# 메인 메모리와 가상 메모리

## TOC

1. [OS에서의 메모리는 정확히 무엇일까?](#1-os에서의-메모리는-정확히-무엇일까)

---

## 1. OS에서의 메모리는 정확히 무엇일까?

> 사실은 성능을 향상시키기 위해서는 메인 메모리에 여러 프로세스가 올라가 있어야 한다. 즉, 여러 프로세스가 메모리를 공유해야 성능이 올라간다.

**메인 메모리 :**

- CPU가 직접 접근할 수 있는 메모리
- 프로그램이 실행될 때 프로그램이 복사되어 메모리에 적재 -> 프로세스가 된다.
- CPU는 PC가 지시하는 대로 연산을 수행한 후 메인 메모리에 데이터를 저장하거나 필요한 데이터를 요구한다.

<p align="center">
    <img src="./resource/memory.PNG"/>
</p>

---

**기본적인 메모리 구성 :**

> 기본적으로 물리 메모리 구현 방법에 대한 개요를 다룬다. 우선적으로 고려해야하는 항목은 다음과 같다.

- `각 프로세스에는 별도의 메모리 공간이 존재`
  - 개별적인 메모리 공간을 분리하기 위해, 특정 프로세스만 접근할 수 있는 합법적인(legal) 메모리 주소 영역을 설정, 프로세스가 합법적인 영역만을 접근하도록 하는 기능이 필요
  - `기본 레지스터` : 가장 작은 합벅적인 물리 메모리 주소
  - `상한 레지스터` : 주어진 영역의 크기

<p align="center">
    <img src="./resource/memory3.png"/>
</p>

> 만약 기준 레지스터값이 300040 이고, 상한이 120900이라면, 기준 ~ 상한의 범위의 주소를 프로세스가 접근할 수 있도록 한다.

---

**메모리 공간의 보호 :**

<p align="center">
    <img src="./resource/memory2.png"/>
</p>

- 기준과 상한 레지스터 하드웨어를 통해서 유저 프로그램이 운영체제나 다른 유저의 코드나 데이터 구조를 수정하는 것을 방지한다.
- 기준 ~ 상한 내부의 범위의 address 만 통과 가능하다.

---

**주소의 할당(Addressing Binding) :**

- 프로그램이 실행되려면, 메모리로 적재한 뒤 `프로세스 컨택스트` 내에 배치해야 함

  - > 프로그램 실행 -> 메모리 적재 -> 프로세스

- 유저 프로그램은 실행되기 전 여러 단계를 거친다.
- 주소는 이 단계에서 여러 다른 방식으로 표시될 수 있음

  - 원시 프로그램에서의 주소는 일반적으로 기호(symbolic)형태로 표현
  - 컴파일러는 이런 기호 주소를 재배치 가능한 주소에 바인딩
    - `예를들어, 여기 모듈 제일 처음에서 15번 뒤 주소로 가주세요.`
  - Linker나 Loader는 재배치 가능한 주소를 절대 주소로 바인딩

> 사용하는 메모리 관리 기법이 뭐냐에 따라서, 프로세스는 실행하는 동안 디스크와 메인 메모리 사이를 왕복 할 수 있다. 대부분 시스템은 유저 프로세스가 메모리에 어떤 부분으로든지 적재될 수 있도록 지원한다. 예를 들어 0000부터 주소가 시작된다고 해도, 가장 첫 프로그램이 0000 부터 시작될 필요는 없다.

---

**유저 프로그램의 단계별 처리 과정 :**

  <p align="center">
      <img src="./resource/memory4.jpg"/>
  </p>

---

**주소 할당의 구분 :**

- 메모리 주소 공간에서 명령어와 데이터의 바인딩은 그 바인딩이 이루어지는 시점에 따라 구분된다.

  - `컴파일 시간 바인딩` : 컴파일 시간에 프로세스가 메모리에 상주할 위치를 미리 알 수 있다면 컴파일러는 절대코드를 생성할 수 있다. 예를들어, 사용자 프로세스가 어떤 특정 번지로부터 시작한다는 것을 미리 알 수 있다면, 컴파일러는 일단 번역해야하는 코드를 그 위치부터 시작한다. 근데 이 위치가 변경이 되어야하는 경우가 있으면 코드가 다시 컴파일해야하는 이슈가 있을 수 있다.

  - `적재 시간 바인딩` : 프로세스가 메모리 어디에 상주할지 컴파일 시간에 알 수 없는 경우 컴파일러는 재배치 가능한 코드를 생성해야 한다. 이 경우에는 심볼, 진짜 메모리 번지 수와의 바인딩이 실제 적재 시간에 이루어진다.

  - `실행 시간 바인딩` : 프로세스가 실행 중에 한 메모리 세그먼트에서 다른 메모리 세그먼트로 이동할 수 있는 경우 바인딩은 실행 시간까지 연기되어야 한다.

---

**논리, 물리 주소 공간 :**

- 컴파일 시간 바인딩, 적재 시간 바인딩 기법은 논리주소와 물리주소가 일치한다.
- 실행 시간 바인딩은 논리주소와 물리주소가 같지 않다.

  - `논리 주소` : CPU에서 생성한 주소(가상 주소)
  - `물리 주소` : 메모리 장치가 보는 주소

- 가상 주소에서 실제 주소로의 실행 시간 맵핑은 MMU(메모리 관리 장치, Memory Management Unit)라고 하는 하드웨어 장치에 의해 수행

  - 주소가 메모리로 전송될 때, 유저 프로세스에 의해 생성된 모든 주소에 재배치 레지스터(기본 레지스터)의 값이 추가된다.
  - 유저 프로그램은 실제 물리적 주소에 절대 접근할 수 없다.

---

**MMU와 동적 재배치 :**

- MMU(Memory management unit)
- 재배치 레지스터를 이용한 동적 재배치

  <p align="center">
      <img src="./resource/memory5.png"/>
  </p>
