# 메인 메모리와 가상 메모리

## TOC

1. [OS에서의 메모리는 정확히 무엇일까?](#1-os에서의-메모리는-정확히-무엇일까)

---

## 1. OS에서의 메모리는 정확히 무엇일까?

> 사실은 성능을 향상시키기 위해서는 메인 메모리에 여러 프로세스가 올라가 있어야 한다. 즉, 여러 프로세스가 메모리를 공유해야 성능이 올라간다.

**메인 메모리 :**

- CPU가 직접 접근할 수 있는 메모리
- 프로그램이 실행될 때 프로그램이 복사되어 메모리에 적재 -> 프로세스가 된다.
- CPU는 PC가 지시하는 대로 연산을 수행한 후 메인 메모리에 데이터를 저장하거나 필요한 데이터를 요구한다.

<p align="center">
    <img src="./resource/memory.PNG"/>
</p>

---

**기본적인 메모리 구성 :**

> 기본적으로 물리 메모리 구현 방법에 대한 개요를 다룬다. 우선적으로 고려해야하는 항목은 다음과 같다.

- `각 프로세스에는 별도의 메모리 공간이 존재`
  - 개별적인 메모리 공간을 분리하기 위해, 특정 프로세스만 접근할 수 있는 합법적인(legal) 메모리 주소 영역을 설정, 프로세스가 합법적인 영역만을 접근하도록 하는 기능이 필요
  - `기본 레지스터` : 가장 작은 합벅적인 물리 메모리 주소
  - `상한 레지스터` : 주어진 영역의 크기

<p align="center">
    <img src="./resource/memory3.png"/>
</p>

> 만약 기준 레지스터값이 300040 이고, 상한이 120900이라면, 기준 ~ 상한의 범위의 주소를 프로세스가 접근할 수 있도록 한다.

---

**메모리 공간의 보호 :**

<p align="center">
    <img src="./resource/memory2.png"/>
</p>

- 기준과 상한 레지스터 하드웨어를 통해서 유저 프로그램이 운영체제나 다른 유저의 코드나 데이터 구조를 수정하는 것을 방지한다.
- 기준 ~ 상한 내부의 범위의 address 만 통과 가능하다.

---

**주소의 할당(Addressing Binding) :**

- 프로그램이 실행되려면, 메모리로 적재한 뒤 `프로세스 컨택스트` 내에 배치해야 함

  - > 프로그램 실행 -> 메모리 적재 -> 프로세스

- 유저 프로그램은 실행되기 전 여러 단계를 거친다.
- 주소는 이 단계에서 여러 다른 방식으로 표시될 수 있음

  - 원시 프로그램에서의 주소는 일반적으로 기호(symbolic)형태로 표현
  - 컴파일러는 이런 기호 주소를 재배치 가능한 주소에 바인딩
    - `예를들어, 여기 모듈 제일 처음에서 15번 뒤 주소로 가주세요.`
  - Linker나 Loader는 재배치 가능한 주소를 절대 주소로 바인딩

> 사용하는 메모리 관리 기법이 뭐냐에 따라서, 프로세스는 실행하는 동안 디스크와 메인 메모리 사이를 왕복 할 수 있다. 대부분 시스템은 유저 프로세스가 메모리에 어떤 부분으로든지 적재될 수 있도록 지원한다. 예를 들어 0000부터 주소가 시작된다고 해도, 가장 첫 프로그램이 0000 부터 시작될 필요는 없다.

---

**유저 프로그램의 단계별 처리 과정 :**

  <p align="center">
      <img src="./resource/memory4.jpg"/>
  </p>

---

**주소 할당의 구분 :**

- 메모리 주소 공간에서 명령어와 데이터의 바인딩은 그 바인딩이 이루어지는 시점에 따라 구분된다.

  - `컴파일 시간 바인딩` : 컴파일 시간에 프로세스가 메모리에 상주할 위치를 미리 알 수 있다면 컴파일러는 절대코드를 생성할 수 있다. 예를들어, 사용자 프로세스가 어떤 특정 번지로부터 시작한다는 것을 미리 알 수 있다면, 컴파일러는 일단 번역해야하는 코드를 그 위치부터 시작한다. 근데 이 위치가 변경이 되어야하는 경우가 있으면 코드가 다시 컴파일해야하는 이슈가 있을 수 있다.

  - `적재 시간 바인딩` : 프로세스가 메모리 어디에 상주할지 컴파일 시간에 알 수 없는 경우 컴파일러는 재배치 가능한 코드를 생성해야 한다. 이 경우에는 심볼, 진짜 메모리 번지 수와의 바인딩이 실제 적재 시간에 이루어진다.

  - `실행 시간 바인딩` : 프로세스가 실행 중에 한 메모리 세그먼트에서 다른 메모리 세그먼트로 이동할 수 있는 경우 바인딩은 실행 시간까지 연기되어야 한다.

---

**논리, 물리 주소 공간 :**

- 컴파일 시간 바인딩은 논리주소와 물리주소가 일치한다.
- 적재 시간 바인딩 기법, 실행 시간 바인딩은 논리주소와 물리주소가 같지 않다.

  - `논리 주소` : CPU에서 생성한 주소(가상 주소)
  - `물리 주소` : 메모리 장치가 보는 주소

- 가상 주소에서 실제 주소로의 실행 시간 맵핑은 MMU(메모리 관리 장치, Memory Management Unit)라고 하는 하드웨어 장치에 의해 수행

  - 주소가 메모리로 전송될 때, 유저 프로세스에 의해 생성된 모든 주소에 재배치 레지스터(기본 레지스터)의 값이 추가된다.
  - 유저 프로그램은 실제 물리적 주소에 절대 접근할 수 없다.

---

**MMU와 동적 재배치 :**

- MMU(Memory management unit)
- 재배치 레지스터를 이용한 동적 재배치

  <p align="center">
      <img src="./resource/memory5.png"/>
  </p>

## 2. 연속 메모리 할당과 단편화

**메모리 보호 :**

- 메모리는 일반적으로 `상주 운영체제용` / `유저 프로세스용`으로 구분
- 일반적으로 여러 유저 프로세스가 메모리에 적재되어 있는 것이 바람직

  - 메모리에 가져오기를 입력 큐에서 기다리고 있는 프로세스에 사용 가능한 메모리를 할당하는 방법 고려 필요

- `메모리 보호` :
  - 재배치 레지스터 : 가장 작은 물리 주소의 값을 저장
  - 상한 레지스터 : 논리 주소의 범위값 저장
  - 각 논리 주소는 상한 레지스터에 의해 지정된 범위 내에 존재해야 한다.
  - MMU는 동적으로 논리 주소에 재배치 레지스터 값을 더하여 주소를 변환한다.

---

**재배치와 상한 레지스터를 지원하는 하드웨어 :**

 <p align="center">
      <img src="./resource/limit-rl.PNG"/>
  </p>

---

**메모리 할당 - 다중 파티션 방식 :**

- 다중 파티션 방식
  - 메모리를 고정된 크기의 여러 파티션으로 나눈다.
  - 각 파티션은 정확히 하나의 프로세스를 포함할 수 있다.
  - 멀티프로그래밍의 정도는 파티션 수에 의해 결정된다.
  - 파티션이 비어 있으면 입력 큐에서 프로세스가 선택되어 비어있는 파티션에 로드된다.
  - 프로세스가 종료되면 파티션을 다른 프로세스에서 사용할 수 있게 된다.

---

**메모리 할당 - 가변 분할 :**

- 가변 분할 기법에서 OS는 사용 가능한 메모리 부분과 사용 중인 메모리 부분을 나타내는 테이블을 유지한다.

- 모든 메모리는 유저 프로세스에 사용 가능하며, 사용 가능한 메모리의 큰 블록을 hole이라고 지칭한다.

 <p align="center">
      <img src="./resource/memory-allocation.PNG"/>
  </p>

---

**동적 메모리 할당 문제 : Free hole들의 리스트로부터 크기가 n인 요청을 어떻게 만족시켜 줄 것인가?**

> 시간이나 메모리 이용 효율 고려가 필요하다.

- `최초 적합` :

  - 첫 번째 사용 가능한 가용 공간 선택
  - 집합의 시작에서부터 검색하거나, 지난번 검색이 끝났던 곳에서 시작
  - 충분히 큰 가용 공간을 찾았을 때 검색 종료

- `최적 적합` :

  - 사용 가능한 공간들 중에서 가장 작은 공간 선택
  - 아주 작은 가용 공간을 만들어 낸다.
  - 리스트가 크기 순으로 되어 있지 않다면 전체 리스트를 검색해야 한다.

- `최악 적합` :
  - 가장 큰 가용 공간 선택
  - 할당 이후 남는 자유공간이 충분히 커서 다른 프로세스들이 사용해야 한다.
  - 자유공간이 크기 순으로 정렬되어 있지 않으면 전 리스트 다 검색해야한다.

---

**단편화(Fragmentation) 개념 :**

> 공간 중에 일부가 사용되지 못하는 부분

- 최초 적합, 최적 적합 모두 `외부단편화`가 발생한다.
- `외부단편화` : 요청을 충족하기에 충분한 총 메모리 공간이 있지만, 사용 가능한 공간이 연속적이지 않은 경우

  - 스토리지가 여러 개의 hole들로 분할된다.

  - 총 메모리 저장 용량과 평균 프로세스 크기에 따라 외부 단편화는 사소하거나 / 중요한 문제일 수 있다.
  - 일반적인 해소 방법 : 물리 메모리를 고정 크기 블록으로 나누고 블록 크기에 따라 정수배로 메모리 할당

- `내부단편화` : 프로세스에 할당된 메모리가 요청된 메모리보다 약간 클 수 있다. 이들 크기 사이의 남는 부분

---

**단편화 - 압축 :**

- 외부 단편화 문제에 대한 하나의 솔루션
- 사용 가능한 모든 메모리를 하나의 큰 블록으로 만들도록 메모리를 모으는 것
- 재배치가 동적이고 실행시간에 수행되는 경우만 가능하다.
- 압축이 가능할 경우 비용 결정이 필요
  - 모든 프로세스를 메모리의 한쪽 끝으로 이동
